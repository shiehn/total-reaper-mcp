"""
Integration tests for Recording Operations in REAPER MCP

These tests cover:
- Track record arm & mode operations
- Track record input configuration
- Recording control (start/stop/toggle)
- Recording settings and metronome
"""

import pytest
import asyncio
from typing import Dict, Any, List
import os
import sys

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from tests.test_base import ReaperMCPTestBase, reaper_test


class TestRecordingOperations(ReaperMCPTestBase):
    """Test recording operations"""
    
    # =========================================================================
    # Track Record Arm & Mode Tests
    # =========================================================================
    
    @reaper_test
    async def test_track_record_arm(self):
        """Test track record arm operations"""
        # Create a test track
        create_result = await self.client.call_tool("insert_track", {
            "index": 0,
            "name": "Test Recording Track"
        })
        self.assertTrue("Track 1 inserted" in create_result.content)
        
        # Test get record arm status (default should be not armed)
        arm_status = await self.client.call_tool("get_track_record_arm", {
            "track_index": 0
        })
        self.assertTrue("not armed" in arm_status.content)
        
        # Arm the track
        arm_result = await self.client.call_tool("set_track_record_arm", {
            "track_index": 0,
            "armed": True
        })
        self.assertTrue("armed for recording" in arm_result.content)
        
        # Verify it's armed
        arm_status2 = await self.client.call_tool("get_track_record_arm", {
            "track_index": 0
        })
        self.assertTrue("is armed" in arm_status2.content)
        
        # Disarm the track
        disarm_result = await self.client.call_tool("set_track_record_arm", {
            "track_index": 0,
            "armed": False
        })
        self.assertTrue("disarmed" in disarm_result.content)
        
        # Toggle arm
        toggle_result = await self.client.call_tool("toggle_track_record_arm", {
            "track_index": 0
        })
        self.assertTrue("armed" in toggle_result.content)
    
    @reaper_test
    async def test_record_modes(self):
        """Test track record mode settings"""
        # Create track
        await self.client.call_tool("insert_track", {
            "index": 0,
            "name": "Mode Test Track"
        })
        
        # Get default record mode
        mode_result = await self.client.call_tool("get_track_record_mode", {
            "track_index": 0
        })
        self.assertTrue("record mode:" in mode_result.content)
        
        # Set different record modes
        modes_to_test = [
            (0, "Input"),
            (1, "Stereo out"),
            (2, "None"),
            (7, "MIDI overdub")
        ]
        
        for mode_val, expected_name in modes_to_test:
            set_result = await self.client.call_tool("set_track_record_mode", {
                "track_index": 0,
                "mode": mode_val
            })
            self.assertTrue(expected_name in set_result.content)
            
            # Verify mode was set
            get_result = await self.client.call_tool("get_track_record_mode", {
                "track_index": 0
            })
            self.assertTrue(expected_name in get_result.content)
        
        # Test string mode names
        string_result = await self.client.call_tool("set_track_record_mode", {
            "track_index": 0,
            "mode": "midi_overdub"
        })
        self.assertTrue("MIDI overdub" in string_result.content)
    
    @reaper_test
    async def test_arm_all_tracks(self):
        """Test arming/disarming all tracks"""
        # Create multiple tracks
        for i in range(3):
            await self.client.call_tool("insert_track", {
                "index": i,
                "name": f"Multi-arm Track {i+1}"
            })
        
        # Arm all tracks
        arm_all_result = await self.client.call_tool("arm_all_tracks", {})
        self.assertTrue("Armed 3 tracks" in arm_all_result.content)
        
        # Get armed tracks list
        armed_list = await self.client.call_tool("get_armed_tracks", {})
        self.assertTrue("Armed tracks:" in armed_list.content)
        self.assertTrue("1: Multi-arm Track 1" in armed_list.content)
        self.assertTrue("2: Multi-arm Track 2" in armed_list.content)
        self.assertTrue("3: Multi-arm Track 3" in armed_list.content)
        
        # Disarm all tracks
        disarm_all_result = await self.client.call_tool("disarm_all_tracks", {})
        self.assertTrue("Disarmed 3 tracks" in disarm_all_result.content)
        
        # Verify all disarmed
        armed_list2 = await self.client.call_tool("get_armed_tracks", {})
        self.assertTrue("No tracks are armed" in armed_list2.content)
    
    # =========================================================================
    # Track Record Input Tests
    # =========================================================================
    
    @reaper_test
    async def test_record_input_configuration(self):
        """Test track record input settings"""
        # Create track
        await self.client.call_tool("insert_track", {
            "index": 0,
            "name": "Input Test Track"
        })
        
        # Get default input
        input_result = await self.client.call_tool("get_track_record_input", {
            "track_index": 0
        })
        self.assertTrue("record input:" in input_result.content)
        
        # Set mono input
        mono_result = await self.client.call_tool("set_track_record_input", {
            "track_index": 0,
            "input_type": "mono",
            "channel": 1
        })
        self.assertTrue("record input to: mono" in mono_result.content)
        
        # Verify mono input
        verify_mono = await self.client.call_tool("get_track_record_input", {
            "track_index": 0
        })
        self.assertTrue("Mono input" in verify_mono.content)
        
        # Set stereo input
        stereo_result = await self.client.call_tool("set_track_record_input", {
            "track_index": 0,
            "input_type": "stereo",
            "channel": 1
        })
        self.assertTrue("record input to: stereo" in stereo_result.content)
        
        # Set no input
        none_result = await self.client.call_tool("set_track_record_input", {
            "track_index": 0,
            "input_type": "none"
        })
        self.assertTrue("record input to: none" in none_result.content)
    
    @reaper_test
    async def test_record_monitoring(self):
        """Test track record monitoring modes"""
        # Create track
        await self.client.call_tool("insert_track", {
            "index": 0,
            "name": "Monitor Test Track"
        })
        
        # Get default monitor mode
        monitor_result = await self.client.call_tool("get_track_record_monitor", {
            "track_index": 0
        })
        self.assertTrue("record monitoring:" in monitor_result.content)
        
        # Test different monitor modes
        monitor_modes = [
            (0, "Off"),
            (1, "Normal"),
            (2, "Not when playing")
        ]
        
        for mode_val, expected_name in monitor_modes:
            set_result = await self.client.call_tool("set_track_record_monitor", {
                "track_index": 0,
                "mode": mode_val
            })
            self.assertTrue(expected_name in set_result.content)
            
            # Verify mode
            get_result = await self.client.call_tool("get_track_record_monitor", {
                "track_index": 0
            })
            self.assertTrue(expected_name in get_result.content)
        
        # Test string mode names
        string_result = await self.client.call_tool("set_track_record_monitor", {
            "track_index": 0,
            "mode": "auto"
        })
        self.assertTrue("Not when playing" in string_result.content)
    
    @reaper_test
    async def test_monitor_armed_tracks(self):
        """Test enabling monitoring on armed tracks"""
        # Create and arm tracks
        for i in range(2):
            await self.client.call_tool("insert_track", {
                "index": i,
                "name": f"Monitor Track {i+1}"
            })
            await self.client.call_tool("set_track_record_arm", {
                "track_index": i,
                "armed": True
            })
        
        # Enable monitoring on armed tracks
        monitor_result = await self.client.call_tool("enable_all_track_monitoring", {})
        self.assertTrue("Enabled monitoring on 2 armed tracks" in monitor_result.content)
        
        # Verify monitoring is enabled
        for i in range(2):
            check_result = await self.client.call_tool("get_track_record_monitor", {
                "track_index": i
            })
            self.assertTrue("Normal" in check_result.content)
    
    @reaper_test
    async def test_get_record_inputs(self):
        """Test getting available record inputs"""
        inputs_result = await self.client.call_tool("get_record_input_list", {})
        self.assertTrue("Available record inputs:" in inputs_result.content)
        self.assertTrue("Audio Inputs:" in inputs_result.content)
        # Note: MIDI inputs section may or may not be present depending on system
    
    # =========================================================================
    # Recording Control Tests
    # =========================================================================
    
    @reaper_test
    async def test_recording_control(self):
        """Test basic recording control"""
        # Get initial status
        status_result = await self.client.call_tool("get_recording_status", {})
        self.assertTrue("Stopped" in status_result.content or "Paused" in status_result.content)
        
        # Start recording
        start_result = await self.client.call_tool("start_recording", {})
        self.assertTrue("Started recording" in start_result.content)
        
        # Check status
        recording_status = await self.client.call_tool("get_recording_status", {})
        self.assertTrue("Recording" in recording_status.content)
        
        # Stop recording
        stop_result = await self.client.call_tool("stop_recording", {})
        self.assertTrue("Stopped recording" in stop_result.content)
        
        # Check status again
        stopped_status = await self.client.call_tool("get_recording_status", {})
        self.assertTrue("Stopped" in stopped_status.content or "Playing" not in stopped_status.content)
    
    @reaper_test
    async def test_toggle_recording(self):
        """Test toggle recording functionality"""
        # Make sure we're stopped first
        await self.client.call_tool("stop_recording", {})
        
        # Toggle to start
        toggle1 = await self.client.call_tool("toggle_recording", {})
        self.assertTrue("Started recording" in toggle1.content)
        
        # Toggle to stop
        toggle2 = await self.client.call_tool("toggle_recording", {})
        self.assertTrue("Stopped recording" in toggle2.content)
    
    @reaper_test
    async def test_auto_punch_recording(self):
        """Test auto-punch recording setup"""
        # Set auto-punch from 5 to 10 seconds
        punch_result = await self.client.call_tool("set_record_mode_auto_punch", {
            "start_time": 5.0,
            "end_time": 10.0
        })
        self.assertTrue("Set auto-punch recording" in punch_result.content)
        self.assertTrue("5.000s to 10.000s" in punch_result.content)
    
    @reaper_test
    async def test_preroll_recording(self):
        """Test pre-roll recording setup"""
        preroll_result = await self.client.call_tool("set_preroll_recording", {
            "preroll_seconds": 3.0
        })
        self.assertTrue("Set pre-roll recording" in preroll_result.content)
        self.assertTrue("3.0 seconds lead-in" in preroll_result.content)
    
    @reaper_test
    async def test_recording_path(self):
        """Test getting recording path"""
        path_result = await self.client.call_tool("get_last_recording_path", {})
        self.assertTrue("Recording path:" in path_result.content)
    
    @reaper_test
    async def test_count_takes(self):
        """Test counting takes in project"""
        # This will return current take count
        takes_result = await self.client.call_tool("count_takes_recorded", {})
        self.assertTrue("Total takes in project:" in takes_result.content)
    
    # =========================================================================
    # Recording Settings Tests
    # =========================================================================
    
    @reaper_test
    async def test_recording_format(self):
        """Test recording format settings"""
        # Get current format
        format_result = await self.client.call_tool("get_recording_format", {})
        self.assertTrue("Recording format:" in format_result.content)
        
        # Set different formats
        wav_result = await self.client.call_tool("set_recording_format", {
            "format_type": "wav",
            "bit_depth": 24,
            "sample_rate": 48000
        })
        self.assertTrue("WAV 24-bit 48000 Hz" in wav_result.content)
        
        # Try FLAC format
        flac_result = await self.client.call_tool("set_recording_format", {
            "format_type": "flac",
            "bit_depth": 16,
            "sample_rate": 44100
        })
        self.assertTrue("FLAC 16-bit 44100 Hz" in flac_result.content)
    
    @reaper_test
    async def test_metronome_settings(self):
        """Test metronome and count-in settings"""
        # Get current settings
        settings_result = await self.client.call_tool("get_metronome_settings", {})
        self.assertTrue("Metronome:" in settings_result.content)
        self.assertTrue("Count-in:" in settings_result.content)
        
        # Toggle metronome
        metro_toggle = await self.client.call_tool("toggle_metronome", {})
        self.assertTrue("Metronome" in metro_toggle.content)
        self.assertTrue("enabled" in metro_toggle.content or "disabled" in metro_toggle.content)
        
        # Toggle count-in
        countin_toggle = await self.client.call_tool("toggle_count_in", {})
        self.assertTrue("Count-in" in countin_toggle.content)
        self.assertTrue("enabled" in countin_toggle.content or "disabled" in countin_toggle.content)
        
        # Get settings again to see changes
        settings_result2 = await self.client.call_tool("get_metronome_settings", {})
        self.assertTrue("Metronome:" in settings_result2.content)


# ============================================================================
# Test Runner
# ============================================================================

def run_recording_tests():
    """Run all recording operation tests"""
    import unittest
    
    # Create test suite
    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(TestRecordingOperations)
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    return result.wasSuccessful()


if __name__ == "__main__":
    success = run_recording_tests()
    sys.exit(0 if success else 1)