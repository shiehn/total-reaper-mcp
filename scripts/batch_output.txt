# Tool definitions for app.py:

        Tool(
            name="get_master_track",
            description="Get the master track",
            inputSchema={
                "type": "object",
                "properties": {}
            }
        ),
        Tool(
            name="delete_track",
            description="Delete a track by index",
            inputSchema={
                "type": "object",
                "properties": {
                    "track_index": {
                        "type": "integer",
                        "description": "The track index (0-based)",
                        "minimum": 0
                    }
                },
                "required": ['track_index']
            }
        ),
        Tool(
            name="get_track_mute",
            description="Get track mute state",
            inputSchema={
                "type": "object",
                "properties": {
                    "track_index": {
                        "type": "integer",
                        "description": "The track index (0-based)",
                        "minimum": 0
                    }
                },
                "required": ['track_index']
            }
        ),
        Tool(
            name="set_track_mute",
            description="Set track mute state",
            inputSchema={
                "type": "object",
                "properties": {
                    "track_index": {
                        "type": "integer",
                        "description": "The track index (0-based)",
                        "minimum": 0
                    },
                    "mute": {
                        "type": "boolean",
                        "description": "Whether to mute (true) or unmute (false) the track"
                    }
                },
                "required": ['track_index', 'mute']
            }
        ),
        Tool(
            name="get_track_solo",
            description="Get track solo state",
            inputSchema={
                "type": "object",
                "properties": {
                    "track_index": {
                        "type": "integer",
                        "description": "The track index (0-based)",
                        "minimum": 0
                    }
                },
                "required": ['track_index']
            }
        ),
        Tool(
            name="set_track_solo",
            description="Set track solo state",
            inputSchema={
                "type": "object",
                "properties": {
                    "track_index": {
                        "type": "integer",
                        "description": "The track index (0-based)",
                        "minimum": 0
                    },
                    "solo": {
                        "type": "boolean",
                        "description": "Whether to solo (true) or unsolo (false) the track"
                    }
                },
                "required": ['track_index', 'solo']
            }
        ),

# Call tool handlers for app.py:

    elif name == "get_master_track":
        
        result = bridge.call_lua("GetMasterTrack", [0])
        
        if result.get("ok"):
            return [TextContent(
                type="text",
                text=f"Master track: {result.get('ret')}"
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Failed to get master track: {result.get('error', 'Unknown error')}"
            )]

    elif name == "delete_track":
        track_index = arguments["track_index"]
        
        # First check if track exists
        track_result = bridge.call_lua("GetTrack", [0, track_index])
        if not track_result.get("ok") or not track_result.get("ret"):
            return [TextContent(
                type="text",
                text=f"Failed to find track at index {track_index}"
            )]
        
        result = bridge.call_lua("DeleteTrack", [track_index])
        
        if result.get("ok"):
            return [TextContent(
                type="text",
                text=f"Track {track_index} deleted successfully"
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Failed to delete track: {result.get('error', 'Unknown error')}"
            )]

    elif name == "get_track_mute":
        track_index = arguments["track_index"]
        
        # First check if track exists
        track_result = bridge.call_lua("GetTrack", [0, track_index])
        if not track_result.get("ok") or not track_result.get("ret"):
            return [TextContent(
                type="text",
                text=f"Failed to find track at index {track_index}"
            )]
        
        result = bridge.call_lua("GetTrackMute", [track_index])
        
        if result.get("ok"):
            return [TextContent(
                type="text",
                text=f"Track {track_index} mute state: {'muted' if result.get('ret') else 'unmuted'}"
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Failed to get track mute: {result.get('error', 'Unknown error')}"
            )]

    elif name == "set_track_mute":
        track_index = arguments["track_index"]
        mute = arguments["mute"]
        
        # First check if track exists
        track_result = bridge.call_lua("GetTrack", [0, track_index])
        if not track_result.get("ok") or not track_result.get("ret"):
            return [TextContent(
                type="text",
                text=f"Failed to find track at index {track_index}"
            )]
        
        result = bridge.call_lua("SetTrackMute", [track_index, mute])
        
        if result.get("ok"):
            return [TextContent(
                type="text",
                text=f"Track {track_index} {'muted' if mute else 'unmuted'}"
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Failed to set track mute: {result.get('error', 'Unknown error')}"
            )]

    elif name == "get_track_solo":
        track_index = arguments["track_index"]
        
        # First check if track exists
        track_result = bridge.call_lua("GetTrack", [0, track_index])
        if not track_result.get("ok") or not track_result.get("ret"):
            return [TextContent(
                type="text",
                text=f"Failed to find track at index {track_index}"
            )]
        
        result = bridge.call_lua("GetTrackSolo", [track_index])
        
        if result.get("ok"):
            return [TextContent(
                type="text",
                text=f"Track {track_index} solo state: {'soloed' if result.get('ret') else 'not soloed'}"
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Failed to get track solo: {result.get('error', 'Unknown error')}"
            )]

    elif name == "set_track_solo":
        track_index = arguments["track_index"]
        solo = arguments["solo"]
        
        # First check if track exists
        track_result = bridge.call_lua("GetTrack", [0, track_index])
        if not track_result.get("ok") or not track_result.get("ret"):
            return [TextContent(
                type="text",
                text=f"Failed to find track at index {track_index}"
            )]
        
        result = bridge.call_lua("SetTrackSolo", [track_index, solo])
        
        if result.get("ok"):
            return [TextContent(
                type="text",
                text=f"Track {track_index} {'soloed' if solo else 'unsoloed'}"
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Failed to set track solo: {result.get('error', 'Unknown error')}"
            )]

# Lua handlers for mcp_bridge.lua:

            elseif fname == "GetMasterTrack" then
                local master = reaper.GetMasterTrack(0)
                response.ok = true
                response.ret = master

            elseif fname == "DeleteTrack" then
                if #args >= 1 then
                    local track = reaper.GetTrack(0, args[1])
                    if track then
                        reaper.DeleteTrack(track)
                        response.ok = true
                    else
                        response.error = "Track not found at index " .. tostring(args[1])
                    end
                else
                    response.error = "DeleteTrack requires 1 argument(s)"
                end

            elseif fname == "GetTrackMute" then
                if #args >= 1 then
                    local track = reaper.GetTrack(0, args[1])
                    if track then
                        local muted = reaper.GetMediaTrackInfo_Value(track, "B_MUTE") == 1
                        response.ok = true
                        response.ret = muted
                    else
                        response.error = "Track not found at index " .. tostring(args[1])
                    end
                else
                    response.error = "GetTrackMute requires 1 argument(s)"
                end

            elseif fname == "SetTrackMute" then
                if #args >= 2 then
                    local track = reaper.GetTrack(0, args[1])
                    if track then
                        reaper.SetMediaTrackInfo_Value(track, "B_MUTE", args[2] and 1 or 0)
                        response.ok = true
                    else
                        response.error = "Track not found at index " .. tostring(args[1])
                    end
                else
                    response.error = "SetTrackMute requires 2 argument(s)"
                end

            elseif fname == "GetTrackSolo" then
                if #args >= 1 then
                    local track = reaper.GetTrack(0, args[1])
                    if track then
                        local solo = reaper.GetMediaTrackInfo_Value(track, "I_SOLO") > 0
                        response.ok = true
                        response.ret = solo
                    else
                        response.error = "Track not found at index " .. tostring(args[1])
                    end
                else
                    response.error = "GetTrackSolo requires 1 argument(s)"
                end

            elseif fname == "SetTrackSolo" then
                if #args >= 2 then
                    local track = reaper.GetTrack(0, args[1])
                    if track then
                        reaper.SetMediaTrackInfo_Value(track, "I_SOLO", args[2] and 1 or 0)
                        response.ok = true
                    else
                        response.error = "Track not found at index " .. tostring(args[1])
                    end
                else
                    response.error = "SetTrackSolo requires 2 argument(s)"
                end

